{"ast":null,"code":"var _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\n\nvar mongoose = require(\"mongoose\");\n\nvar _require = require(\"validator\"),\n    isEmail = _require.isEmail;\n\nvar bcrypt = require(\"bcrypt\");\n\nvar userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    validate: [isEmail],\n    lowercase: true,\n    unique: true,\n    trim: true\n  },\n  password: {\n    type: String,\n    required: true,\n    max: 1024,\n    minlength: 6\n  },\n  bio: {\n    type: String,\n    max: 1024\n  },\n  foodToRecipe: [String],\n  shoppingList: [String],\n  usersfood: {\n    type: [{\n      foodId: Number,\n      foodName: String,\n      foodCarbon: String,\n      foodExpiration: Number,\n      foodCategory: String,\n      foodLogo: String,\n      foodQuantity: Number,\n      timestamp: Number\n    }]\n  }\n}, {\n  timestamps: true\n});\nuserSchema.pre(\"save\", function () {\n  var _ref = _asyncToGenerator(function* (next) {\n    var salt = yield bcrypt.genSalt();\n    this.password = yield bcrypt.hash(this.password, salt);\n    next();\n  });\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}());\n\nuserSchema.statics.login = function () {\n  var _ref2 = _asyncToGenerator(function* (email, password) {\n    var user = yield this.findOne({\n      email: email\n    });\n\n    if (user) {\n      var auth = yield bcrypt.compare(password, user.password);\n\n      if (auth) {\n        return user;\n      }\n\n      throw Error(\"incorrect password\");\n    }\n\n    throw Error(\"incorrect email\");\n  });\n\n  return function (_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar UserModel = mongoose.model(\"user\", userSchema);\nmodule.exports = UserModel;","map":{"version":3,"names":["mongoose","require","isEmail","bcrypt","userSchema","Schema","email","type","String","required","validate","lowercase","unique","trim","password","max","minlength","bio","foodToRecipe","shoppingList","usersfood","foodId","Number","foodName","foodCarbon","foodExpiration","foodCategory","foodLogo","foodQuantity","timestamp","timestamps","pre","next","salt","genSalt","hash","statics","login","user","findOne","auth","compare","Error","UserModel","model","module","exports"],"sources":["/Users/elodiepradet/Documents/react native/Fridgeease/server/models/user.model.js"],"sourcesContent":["const mongoose = require(\"mongoose\");\n//library to validate emails\nconst { isEmail } = require(\"validator\");\nconst bcrypt = require(\"bcrypt\");\n\nconst userSchema = new mongoose.Schema(\n  {\n    email: {\n      type: String,\n      required: true,\n      validate: [isEmail],\n      lowercase: true,\n      unique: true,\n      trim: true,\n    },\n    password: {\n      type: String,\n      required: true,\n      max: 1024,\n      minlength: 6,\n    },\n\n    bio: {\n      type: String,\n      max: 1024,\n    },\n    foodToRecipe: [String],\n    shoppingList: [String],\n    usersfood: {\n      type: [\n        {\n          foodId: Number,\n          foodName: String,\n          foodCarbon: String,\n          foodExpiration: Number,\n          foodCategory: String,\n          foodLogo: String,\n          foodQuantity: Number,\n          timestamp: Number,\n        },\n      ],\n    },\n  },\n  {\n    timestamps: true,\n  }\n);\n\n//this password crypting function is played before saving into db so that the password gets crypted before getting into db\nuserSchema.pre(\"save\", async function (next) {\n  const salt = await bcrypt.genSalt();\n  this.password = await bcrypt.hash(this.password, salt);\n  next();\n});\n\n//checking if user wrote the write info when trying to sign in\nuserSchema.statics.login = async function (email, password) {\n  const user = await this.findOne({ email });\n  if (user) {\n    const auth = await bcrypt.compare(password, user.password);\n    if (auth) {\n      return user;\n    }\n    throw Error(\"incorrect password\");\n  }\n  throw Error(\"incorrect email\");\n};\n\nconst UserModel = mongoose.model(\"user\", userSchema);\n\nmodule.exports = UserModel;\n"],"mappings":";;AAAA,IAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AAEA,eAAoBA,OAAO,CAAC,WAAD,CAA3B;AAAA,IAAQC,OAAR,YAAQA,OAAR;;AACA,IAAMC,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AAEA,IAAMG,UAAU,GAAG,IAAIJ,QAAQ,CAACK,MAAb,CACjB;EACEC,KAAK,EAAE;IACLC,IAAI,EAAEC,MADD;IAELC,QAAQ,EAAE,IAFL;IAGLC,QAAQ,EAAE,CAACR,OAAD,CAHL;IAILS,SAAS,EAAE,IAJN;IAKLC,MAAM,EAAE,IALH;IAMLC,IAAI,EAAE;EAND,CADT;EASEC,QAAQ,EAAE;IACRP,IAAI,EAAEC,MADE;IAERC,QAAQ,EAAE,IAFF;IAGRM,GAAG,EAAE,IAHG;IAIRC,SAAS,EAAE;EAJH,CATZ;EAgBEC,GAAG,EAAE;IACHV,IAAI,EAAEC,MADH;IAEHO,GAAG,EAAE;EAFF,CAhBP;EAoBEG,YAAY,EAAE,CAACV,MAAD,CApBhB;EAqBEW,YAAY,EAAE,CAACX,MAAD,CArBhB;EAsBEY,SAAS,EAAE;IACTb,IAAI,EAAE,CACJ;MACEc,MAAM,EAAEC,MADV;MAEEC,QAAQ,EAAEf,MAFZ;MAGEgB,UAAU,EAAEhB,MAHd;MAIEiB,cAAc,EAAEH,MAJlB;MAKEI,YAAY,EAAElB,MALhB;MAMEmB,QAAQ,EAAEnB,MANZ;MAOEoB,YAAY,EAAEN,MAPhB;MAQEO,SAAS,EAAEP;IARb,CADI;EADG;AAtBb,CADiB,EAsCjB;EACEQ,UAAU,EAAE;AADd,CAtCiB,CAAnB;AA4CA1B,UAAU,CAAC2B,GAAX,CAAe,MAAf;EAAA,6BAAuB,WAAgBC,IAAhB,EAAsB;IAC3C,IAAMC,IAAI,SAAS9B,MAAM,CAAC+B,OAAP,EAAnB;IACA,KAAKpB,QAAL,SAAsBX,MAAM,CAACgC,IAAP,CAAY,KAAKrB,QAAjB,EAA2BmB,IAA3B,CAAtB;IACAD,IAAI;EACL,CAJD;;EAAA;IAAA;EAAA;AAAA;;AAOA5B,UAAU,CAACgC,OAAX,CAAmBC,KAAnB;EAAA,8BAA2B,WAAgB/B,KAAhB,EAAuBQ,QAAvB,EAAiC;IAC1D,IAAMwB,IAAI,SAAS,KAAKC,OAAL,CAAa;MAAEjC,KAAK,EAALA;IAAF,CAAb,CAAnB;;IACA,IAAIgC,IAAJ,EAAU;MACR,IAAME,IAAI,SAASrC,MAAM,CAACsC,OAAP,CAAe3B,QAAf,EAAyBwB,IAAI,CAACxB,QAA9B,CAAnB;;MACA,IAAI0B,IAAJ,EAAU;QACR,OAAOF,IAAP;MACD;;MACD,MAAMI,KAAK,CAAC,oBAAD,CAAX;IACD;;IACD,MAAMA,KAAK,CAAC,iBAAD,CAAX;EACD,CAVD;;EAAA;IAAA;EAAA;AAAA;;AAYA,IAAMC,SAAS,GAAG3C,QAAQ,CAAC4C,KAAT,CAAe,MAAf,EAAuBxC,UAAvB,CAAlB;AAEAyC,MAAM,CAACC,OAAP,GAAiBH,SAAjB"},"metadata":{},"sourceType":"script"}